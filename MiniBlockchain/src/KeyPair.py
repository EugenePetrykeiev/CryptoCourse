import os
import random
from datetime import datetime
from ecdsa.util import PRNG
from ecdsa import SigningKey, SECP256k1, VerifyingKey, SigningKey, BadSignatureError
from hashlib import sha256


class KeyPair(object):
    private_key = None
    public_key = None
    _dir = '../keys/'
    public_key_path = _dir + 'public.pem'
    private_key_path = _dir + 'private.pem'

    def __init__(self, pubkey: str = None, privatekey: str = None):
        self.public_key = pubkey
        self.private_key = privatekey

    def genKeyPair(self):
        """
        Cryptographically secure pseudorandom number generator used for seed.

        Keys generated by ECDSA (SECP256k1 curve)

        Results will give in PEM files encoding into *.pem (BASE64) and hex values as strings

        """
        random_seed = self._csprng()
        rng1 = PRNG(random_seed)
        sk = SigningKey.generate(curve=SECP256k1, entropy=rng1)
        vk = sk.verifying_key
        self._gen_pem_files(sk.to_pem(), vk.to_pem())
        self.private_key, self.public_key = self._hex_keys(sk, vk)
    @staticmethod
    def key_verification(prvk:str, pbk:str):
        msg = b'012345678'
        verify_key = VerifyingKey.from_pem(open(prvk).read())
        sign_key = SigningKey.from_pem(open(pbk).read())
        sign = sign_key.sign(msg)
        try:
            verify_key.verify(sign, msg)
            print('Good sign')
        except BadSignatureError:
            print('Bad sign')

    def _csprng(self) -> bytes:
        sys_random = random.SystemRandom(datetime.now())
        random_seed = sys_random.getrandbits(256)
        random_seed = bytes(hex(random_seed)[2:], 'utf-8')
        return random_seed

    def _gen_pem_files(self, private_pem: bytes, public_pem: bytes):
        if not os.path.exists(self._dir):
            os.makedirs(self._dir)
        with open(self.private_key_path, "wb") as f:
            f.write(private_pem)
        with open(self.public_key_path, "wb") as f:
            f.write(public_pem)

    def _hex_keys(self, secret: SigningKey, verify: SigningKey) -> tuple:
        pk = secret.to_der().hex()
        pbk = verify.to_der().hex()
        return pk, pbk

    def printKeyPair(self):
        print('Private uncompressed key: ', self.private_key)
        print('Public uncompressed key: ', self.public_key)

    def toString(self):
        pass

    def __repr__(self):
        return self.private_key, self.public_key


class PublicKey(KeyPair):
    _path = ''
    pub_key = None
    _vk = None

    def __init__(self, pub_key_path: str = None):
        super().__init__()
        if pub_key_path is None or not os.path.exists(pub_key_path):
            if os.path.exists(self.public_key_path):
                print('Key already generated')
                self._path = self.public_key_path
                return
            print('New key pair was created')
            self.genKeyPair()
            self._path = self.public_key_path
        if pub_key_path is not None:
            self._path = pub_key_path

    def __call__(self):
        self._vk = VerifyingKey.from_pem(open(self._path).read())
        self.pub_key = self._vk.to_der().hex()
        super().__init__(pubkey=self.pub_key)
        return self.pub_key

    def __repr__(self):
        return self.pub_key

    def printKey(self):
        print("uncompressed: {0}".format(self._vk.to_string("uncompressed").hex()))
        print("compressed: {0}".format(self._vk.to_string("compressed").hex()))


class PrivateKey(KeyPair):
    _path = ''
    prv_key = None
    _sk = None

    def __init__(self, prv_key_path: str = None):
        super().__init__()
        if prv_key_path is None or not os.path.exists(prv_key_path):
            if os.path.exists(self.private_key_path):
                print('Key already generated')
                self._path = self.private_key_path
                return
            print('New key pair was created')
            self.genKeyPair()
            self._path = self.private_key_path
        if prv_key_path is not None:
            self._path = prv_key_path

    def __call__(self):
        self._sk = SigningKey.from_pem(open(self._path).read())
        self.prv_key = self._sk.to_der().hex()
        super().__init__(privatekey=self.prv_key)
        return self.prv_key

    def __repr__(self):
        return self.prv_key

    def printKey(self):
        print("uncompressed: {0}".format(self._sk.to_der().hex()))
        print("compressed: {0}".format(self._sk.to_string().hex()))
